# 힙(heap)

힙(Heap)이라는 자료 구조는 ***완전 이진 트리**의 한 종류입니다. 이 구조는 일련의 규칙에 따라 정렬되는 특징이 있습니다.

이런 규칙의 한 예로는 "모든 노드는 자식 노드들보다 크거나 같다"

(또는 "모든 노드는 자식 노드들보다 작거나 같다")는 것이 있습니다. 

전자의 경우를 **최대 힙(Max Heap)**, 후자의 경우를 **최소 힙(Min Heap)**이라고 합니다.

**최대 힙**에서는 **가장 큰 값이 루트**에 위치하며, **최소 힙**에서는 **가장 작은 값이 루트**에 위치합니다. 

또한, 힙은 항상 균형을 유지하는 특성이 있습니다. 즉, 왼쪽과 오른쪽의 높이 차이가 많아봐야 1입니다.

## ***완전 이진 트리**

이진 트리에 노드를 삽입할 때 왼쪽부터 차례대로 삽입하는 트리이다.

위 그림과 같이 나타내며, 왼쪽이 비어있고 오른쪽이 채워져 있는 형태는 완전 이진 트리라고 할 수 없다.

## ***힙 vs 이진 탐색 트리**

이진 탐색과 연결리스트(linked-list)를 결합한 자료구조의 일종이다.

이진 탐색의 효율적인 탐색 능력을 유지하면서 빈번한 자료의 입력과 삭제를 가능하도록 한다.

각 노드에서 **왼쪽의 자식 노드는 해당 노드보다 작은 값**으로, **오른쪽의 자식 노드는 해당 노드보다 큰 값**으로 이루어져 있다.

### 공통점

- 모두 완전 이진 트리이다.

### 차이점

- (최대힙의 경우) 힙은 각 노드의 값이 자식 노드보다 크거나 같다.
- 이진 탐색 트리는 각 노드의 왼쪽 자식은 더 작은 값으로, 오른쪽 자식은 더 큰 값으로 이루어져있다.`왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드`
- 힙은 왼쪽 노드의 값이 크든 오른쪽 노드의 값이 크든 상관 없다.
- 힙은 최대/최소 검색을, 이진 탐색 트리는 탐색을 위한 구조이다.

힙의 주요 작동 방식은 다음과 같습니다:

**삽입**: 새로운 요소는 일반적으로 트리의 가장 하단에 추가되며, 이후 '거품이 올라가는(bubble up)' 과정을 거쳐서 적절한 위치로 이동합니다. 이 과정은 새 요소가 부모 노드보다 작거나 큰 경우 계속해서 반복됩니다.

```markdown
# 최대 힙의 기본 상태
			8
     / \
    5   7
   / \
  3   4

# 새로운 값 10 추가
			 8
     /   \
    5     7
   / \   /
  3   4 10
# 자식 10 이 부모 7 이 더 큼으로 교체
			 8
     /   \
    5     10
   / \   /
  3   4 7
# 자식 10 이 부모 8보다 큼으로 교체
		  10
     /   \
    5     8
   / \   / 
  3   4 7
```

**삭제**: 최대 힙에서는 가장 큰 요소(루트)가, 최소 힙에서는 가장 작은 요소(루트)가 삭제됩니다. 삭제된 노드의 자리는 가장 마지막 노드가 차지하게 됩니다. 이후 '거품이 내려가는(bubble down)' 과정을 거쳐서 적절한 위치로 이동하게 됩니다.

```markdown
# 최대 힙의 기본 상태
			10
     /   \
    5     8
   / \   / 
  3   4 7
# 10 삭제되고 가장 마지막 노드의 7 이 올라옴
			7
     / \
    5   8
   / \
  3   4
# 이후 자식노드 8이 더 큼으로 교체.
			8
     / \
    5   7
   / \
  3   4
```

## 사용할 수 있는 문제

힙 정렬(Heap Sort): 힙 정렬은 힙을 사용하는 효율적인 정렬 알고리즘이다. 배열을 최대 힙으로 구성한 다음, 가장 큰 원소(루트)를 배열의 마지막 원소와 교환하고 힙 크기를 줄인다. 이 과정을 반복하면 배열이 오름차순으로 정렬된다.

우선 순위 큐(Priority Queue): 힙은 효과적인 우선 순위 큐를 구현하는 데 사용될 수 있다. 최대 힙에서는 가장 높은 우선 순위를 가진 원소가 루트에 위치하고, 최소 힙에서는 가장 낮은 우선 순위를 가진 원소가 루트에 위치한다. 이러한 특성 덕분에 힙을 사용하면 우선 순위에 따라 원소를 삽입하거나 삭제하는 연산을 빠르게 수행할 수 있다.

K번째 최대(또는 최소) 원소 찾기: 힙을 사용하면 데이터에서 K번째로 큰(또는 작은) 원소를 효율적으로 찾을 수 있다. 예를 들어, 최소 힙을 사용하면 K번 루트 원소를 삭제하면 K번째로 작은 원소를 얻을 수 있다.

## 코드에서 사용하기

힙 구현하는데 Java의 PriorityQueue 클래스를 사용할 수 있음

다음은 다양한 기능을 코드로 구현한 예제

```kotlin
//선언하기
val pq1 = PriorityQueue<Int>()  // 빈 PriorityQueue 생성

val initialCapacity = 10
val pq2 = PriorityQueue<Int>(initialCapacity)  // 초기 용량 지정

val pq3 = PriorityQueue<Int>(compareBy { it })  // Comparator를 사용하여 우선 순위 결정
```

```kotlin
//add() 또는 offer() 메서드를 사용하여 PriorityQueue에 원소를 추가할 수 있습니다.
pq1.add(10) //원소를 추가할 수 없으면 예외 발생
pq1.offer(20) //원소 추가여부에 따른 boolean값 반환

//remove(), poll() 메서드를 사용하여 PriorityQueue에서 원소를 제거할 수 있습니다.
val topElement1 = pq1.remove()  // 큐가 비어 있을 경우 NoSuchElementException을 던짐
val topElement2 = pq1.poll()  // 큐가 비어 있을 경우 null 반환

//peek() 메서드를 사용하여 가장 높은 우선 순위의 원소를 조회할 수 있습니다.
val topElement = pq1.peek()  // 큐가 비어 있을 경우 null 반환

//size 속성을 사용하여 PriorityQueue의 크기를 조회할 수 있습니다.
val size = pq1.size // 사이즈 반환

//clear() 메서드를 사용하여 PriorityQueue의 모든 원소를 제거할 수 있습니다.
pq1.clear()

//특정 원소가 큐에 있는지 확인: contains() 메서드를 사용하여 PriorityQueue에 특정 원소가 있는지 확인할 수 있습니다.
val contains = pq1.contains(10)
```
